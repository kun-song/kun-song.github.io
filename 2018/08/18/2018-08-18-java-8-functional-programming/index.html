<!DOCTYPE html>







<html class="theme-next pisces" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



















  
  
  
  

  

  

  

  

  

  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="面向对象编程是对 数据 进行抽象，函数式编程是对 行为 进行抽象，现实世界中数据与行为并存，为不同的任务选择合适的抽象方式，两全其美。 通常而言，函数式代码在 效率 上不是最优的，但可读性比面向对象代码好，如今处理器性能已经过剩，若不是特别关注效率的场景，则可读性优先。 虽然 Java 8 对 FP 支持偏薄弱，例如不支持惰性求值、不可变数据结构、typeclass 等，但相比以前，已经大大进步了">
<meta name="keywords" content="Java,fp">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 8 Stream 入门">
<meta property="og:url" content="http://songkun.me/2018/08/18/2018-08-18-java-8-functional-programming/index.html">
<meta property="og:site_name" content="随便写写">
<meta property="og:description" content="面向对象编程是对 数据 进行抽象，函数式编程是对 行为 进行抽象，现实世界中数据与行为并存，为不同的任务选择合适的抽象方式，两全其美。 通常而言，函数式代码在 效率 上不是最优的，但可读性比面向对象代码好，如今处理器性能已经过剩，若不是特别关注效率的场景，则可读性优先。 虽然 Java 8 对 FP 支持偏薄弱，例如不支持惰性求值、不可变数据结构、typeclass 等，但相比以前，已经大大进步了">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://songkun.me/images/java-8-lambdas/outer-iteration.png">
<meta property="og:image" content="http://songkun.me/images/java-8-lambdas/inner-iteration.png">
<meta property="og:updated_time" content="2019-07-07T11:13:18.586Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 8 Stream 入门">
<meta name="twitter:description" content="面向对象编程是对 数据 进行抽象，函数式编程是对 行为 进行抽象，现实世界中数据与行为并存，为不同的任务选择合适的抽象方式，两全其美。 通常而言，函数式代码在 效率 上不是最优的，但可读性比面向对象代码好，如今处理器性能已经过剩，若不是特别关注效率的场景，则可读性优先。 虽然 Java 8 对 FP 支持偏薄弱，例如不支持惰性求值、不可变数据结构、typeclass 等，但相比以前，已经大大进步了">
<meta name="twitter:image" content="http://songkun.me/images/java-8-lambdas/outer-iteration.png">






  <link rel="canonical" href="http://songkun.me/2018/08/18/2018-08-18-java-8-functional-programming/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java 8 Stream 入门 | 随便写写</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?846ea2c0fbfe48d1fc36a417a790a68c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/satansk"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Follow me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">随便写写</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-books">
    <a href="/books" rel="section">
      <i class="menu-item-icon fa fa-fw fa-book"></i> <br>书单</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://songkun.me/2018/08/18/2018-08-18-java-8-functional-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Song Kun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随便写写">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 8 Stream 入门
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-18 12:24:17" itemprop="dateCreated datePublished" datetime="2018-08-18T12:24:17+08:00">2018-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-07 19:13:18" itemprop="dateModified" datetime="2019-07-07T19:13:18+08:00">2019-07-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>面向对象编程是对 <strong>数据</strong> 进行抽象，函数式编程是对 <strong>行为</strong> 进行抽象，现实世界中数据与行为并存，为不同的任务选择合适的抽象方式，两全其美。</p>
<p>通常而言，函数式代码在 <strong>效率</strong> 上不是最优的，但可读性比面向对象代码好，如今处理器性能已经过剩，若不是特别关注效率的场景，则可读性优先。</p>
<p>虽然 Java 8 对 FP 支持偏薄弱，例如不支持惰性求值、不可变数据结构、typeclass 等，但相比以前，已经大大进步了。</p>
<a id="more"></a>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>为了实现类似 Scala 的超级好用的集合组合子，Java 必须在语言层面变革：新增 lambda 表达式。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>task</code> 类型为 <code>Runnable</code></li>
<li><code>add</code> 类型为 <code>BinaryOperator&lt;Long&gt;</code></li>
</ul>
<h3 id="final-变量"><a href="#final-变量" class="headerlink" title="final 变量"></a><code>final</code> 变量</h3><p>lambda 表达式中引用的局部变量必须是：</p>
<ul>
<li><code>final</code> 变量，或</li>
<li>事实上的 <code>final</code> 变量</li>
</ul>
<p><code>final</code> 变量很好理解，实际上的 <code>final</code> 变量即 <strong>只赋值过一次</strong> 的变量，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">Runnable task = () -&gt; System.out.println(n);</span><br></pre></td></tr></table></figure>
<p>若再次为 <code>n</code> 赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line">Runnable task = () -&gt; System.out.println(n);</span><br></pre></td></tr></table></figure>
<p>编译器提示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Variable used in lambda expression should be <span class="keyword">final</span> or effectively <span class="keyword">final</span></span><br></pre></td></tr></table></figure>
<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><blockquote>
<p>函数接口是只有一个 <strong>抽象方法</strong> 的接口，用作 lambda 表达式的类型。</p>
</blockquote>
<p><code>BiFunction</code> 即为函数接口，因为它只有 <code>apply</code> 一个抽象方法（abstract method），<code>andThen</code> 是已经实现的默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BiFunction</code> 是接口，所以不需要用 <code>abstract</code> 修饰 <code>apply</code> 方法；</li>
</ul>
<p>函数接口的唯一抽象方法的 <strong>名字并不重要</strong>，一般不会直接使用，习惯将其命名为 <code>apply</code>，其参数类型、返回类型比较重要。</p>
<p>JDK 常见函数接口如下：</p>
<ul>
<li><code>Predicate&lt;T&gt;</code> 类型为 <code>T =&gt; Boolean</code></li>
<li><code>Consumer&lt;T&gt;</code> 类型为 <code>T =&gt; Void</code></li>
<li><code>Function&lt;T, R&gt;</code> 类型为 <code>T =&gt; R</code></li>
<li><code>Supplier&lt;T&gt;</code> 类型为 <code>() =&gt; T</code></li>
<li><code>UnaryOperator&lt;T&gt;</code> 类型为 <code>T =&gt; T</code></li>
<li><code>BinaryOperator&lt;T, R&gt;</code> 类型为 <code>(T, T) =&gt; T</code></li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>不少类通过 lambda 表达式得到了增强，例如若要创建具备初始值的 <code>ThreadLocal</code> 实例，以前需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal t = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Java 8 可以用 <code>Supplier</code> 创建，更加易读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal t = ThreadLocal.withInitial(() -&gt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>看下 <code>withInitial</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>SuppliedThreadLocal</code> 则覆盖了默认的 <code>initialValue</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An extension of ThreadLocal that obtains its initial value from</span></span><br><span class="line"><span class="comment"> * the specified &#123;<span class="doctag">@code</span> Supplier&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>Java 8 通过 lambda 表达式大大提升了集合操作的可用性，包括：</p>
<ul>
<li>集合 API 增强</li>
<li><code>Stream</code></li>
</ul>
<h3 id="外部迭代-vs-内部迭代"><a href="#外部迭代-vs-内部迭代" class="headerlink" title="外部迭代 vs 内部迭代"></a>外部迭代 vs 内部迭代</h3><p>传统的 <code>for</code> 迭代存在以下缺点：</p>
<ul>
<li>不易并行</li>
<li>语法噪音影响理解，对于复杂、嵌套的迭代尤其明显</li>
</ul>
<p><code>for</code> 循环是通过 <strong>外部迭代</strong> 实现的，即首先调用集合的 <code>interator()</code> 方法产生一个 <code>Iterator</code> 对象，然后通过该对象的 <code>hasNext</code> 和 <code>next</code> 方法控制迭代过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Iterator&lt;Artist&gt; iterator = allArtists.iterator(); </span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Artist artist = iterator.next(); </span><br><span class="line">    <span class="keyword">if</span> (artist.isFrom(<span class="string">"London"</span>)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部迭代过程如下图：</p>
<p><img src="/images/java-8-lambdas/outer-iteration.png" alt="外部迭代" style="width: 400px;"></p>
<p>Java 8 添加的 <code>stream()</code> 方法类似 <code>iterator()</code>，但返回的不是 <code>Iterator</code> 对象，而是用于内部迭代的 <code>Stream</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = allArtists.stream()</span><br><span class="line">                       .filter(artist -&gt; artist.isFrom(<span class="string">"London"</span>))</span><br><span class="line">                       .count();</span><br></pre></td></tr></table></figure>
<p>内部迭代过程如下图：</p>
<p><img src="/images/java-8-lambdas/inner-iteration.png" alt="外部迭代" style="width: 400px;"></p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p><code>Stream</code> 方法有两种求值策略：</p>
<ul>
<li>返回值为 <code>Stream</code> 的方法，如 <code>filter</code>，是 lazy evaluation</li>
<li>返回值非 <code>Stream</code>（包含 <code>void</code>），如 <code>count</code>，是 eager evalution</li>
</ul>
<p>使用 <code>Stream</code> 的一般模式是，创建一组 lazy 求值方法组成的调用链，最后用一个 eager 求值方法终结之，整个调用链将只对集合迭代一次。</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="collect-toList"><a href="#collect-toList" class="headerlink" title="collect(toList())"></a><code>collect(toList())</code></h4><p><code>collect</code> 非常强大，生成 <code>List</code> 仅仅是最简单的应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">                               .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"hello"</span>)</span><br><span class="line">                               .map(string -&gt; string.toUpperCase()) 􏰐</span><br><span class="line">                               .collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; beginningWithNumbers</span><br><span class="line">       = Stream.of(<span class="string">"a"</span>, <span class="string">"1abc"</span>, <span class="string">"abc1"</span>)</span><br><span class="line">               .filter(value -&gt; isDigit(value.charAt(<span class="number">0</span>)))</span><br><span class="line">               .collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><code>flatMap</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; together = Stream.of(asList(<span class="number">1</span>, <span class="number">2</span>), asList(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">                               .flatMap(numbers -&gt; numbers.stream())</span><br><span class="line">                               .collect(toList());</span><br></pre></td></tr></table></figure>
<h4 id="max-和-min"><a href="#max-和-min" class="headerlink" title="max 和 min"></a><code>max</code> 和 <code>min</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Track&gt; tracks = asList(<span class="keyword">new</span> Track(<span class="string">"Bakai"</span>, <span class="number">524</span>), <span class="keyword">new</span> Track(<span class="string">"Violets for Your Furs"</span>, <span class="number">378</span>), <span class="keyword">new</span> Track(<span class="string">"Time Was"</span>, <span class="number">451</span>));</span><br><span class="line"></span><br><span class="line">Track shortestTrack = tracks.stream()</span><br><span class="line">                            .min(Comparator.comparing(track -&gt; track.getLength()))</span><br><span class="line">                            .get();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>max</code> 和 <code>min</code> 返回值都是 <code>Optional</code>；</li>
</ul>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><code>reduce</code></h4><p><code>reduce</code> 将一组值归约（reduce）为一个值，<code>count</code>、<code>max</code> 和 <code>min</code> 都是 <code>reduce</code> 的特例，因为过于常见，标准库将其单独定义。</p>
<p>利用 <code>reduce</code> 求和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">                .reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<ul>
<li>该求和方式仅为演示 <code>reduce</code> 用法，生产环境不要用！</li>
</ul>
<h4 id="返回-Stream-的方法"><a href="#返回-Stream-的方法" class="headerlink" title="返回 Stream 的方法"></a>返回 <code>Stream</code> 的方法</h4><p>相对返回 <code>List</code> 或 <code>Set</code>，返回 <code>Stream</code> 仅仅暴露了 <code>Stream</code> 接口，用户无法通过返回的 <code>Stream</code> 修改背后的集合！</p>
<h4 id="多次调用-Stream-操作"><a href="#多次调用-Stream-操作" class="headerlink" title="多次调用 Stream 操作"></a>多次调用 <code>Stream</code> 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Artist&gt; musicians = album.getMusicians()</span><br><span class="line">                              .collect(toList());</span><br><span class="line">List&lt;Artist&gt; bands = musicians.stream()</span><br><span class="line">                              .filter(artist -&gt; artist.getName().startsWith(<span class="string">"The"</span>))</span><br><span class="line">                              .collect(toList());</span><br><span class="line">Set&lt;String&gt; origins = bands.stream()</span><br><span class="line">                           .map(artist -&gt; artist.getNationality())</span><br><span class="line">                           .collect(toSet());</span><br></pre></td></tr></table></figure>
<p>以上代码缺点：</p>
<ol>
<li>可读性差，样板代码太多，隐藏了真实的代码意图；</li>
<li>效率差，每一步都强制计算，生成新集合；</li>
<li>垃圾中间变量；</li>
<li>难以并行化；</li>
</ol>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; origins = album.getMusicians()</span><br><span class="line">                           .filter(artist -&gt; artist.getName().startsWith(<span class="string">"The"</span>))</span><br><span class="line">                           .map(artist -&gt; artist.getNationality())</span><br><span class="line">                           .collect(toSet());</span><br></pre></td></tr></table></figure>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>用 <code>reduce</code> 实现 <code>filter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(Stream&lt;T&gt; xs, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">  BiFunction&lt;List&lt;T&gt;, T, List&lt;T&gt;&gt; accumulator =</span><br><span class="line">  (acc, x) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.test(x)) &#123;</span><br><span class="line">      List&lt;T&gt; newAcc = <span class="keyword">new</span> ArrayList&lt;&gt;(acc);</span><br><span class="line">      newAcc.add(x);</span><br><span class="line">      <span class="keyword">return</span> newAcc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;;</span><br><span class="line">BinaryOperator&lt;List&lt;T&gt;&gt; combiner =</span><br><span class="line">  (zs, ys) -&gt; &#123;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(zs);</span><br><span class="line">    result.addAll(ys);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> xs.reduce(Collections.emptyList(), accumulator, combiner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List(3, 4)</span></span><br><span class="line">List&lt;Integer&gt; xs = filter(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), n -&gt; n &gt; <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>用 <code>reduce</code> 实现 <code>map</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(Stream&lt;T&gt; xs, Function&lt;T, R&gt; mapper)</span> </span>&#123;</span><br><span class="line">  BiFunction&lt;List&lt;R&gt;, T, List&lt;R&gt;&gt; accumulator =</span><br><span class="line">    (acc, x) -&gt; &#123;</span><br><span class="line">      List&lt;R&gt; newAcc = <span class="keyword">new</span> ArrayList&lt;&gt;(acc);</span><br><span class="line">      newAcc.add(mapper.apply(x));</span><br><span class="line">      <span class="keyword">return</span> newAcc;</span><br><span class="line">    &#125;;</span><br><span class="line">  BinaryOperator&lt;List&lt;R&gt;&gt; combiner =</span><br><span class="line">    (zs, ys) -&gt; &#123;</span><br><span class="line">      List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(zs);</span><br><span class="line">      result.addAll(ys);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> xs.reduce(Collections.emptyList(), accumulator, combiner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List(2, 3, 4, 5)</span></span><br><span class="line">List&lt;Integer&gt; ys = map(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), n -&gt; n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p><code>int</code> 作为基本类型，有与之对应的装箱类型 <code>Integer</code>：</p>
<ul>
<li>两者内存占用不同（<code>int</code> 4 字节，<code>Integer</code> 16 字节），最坏情况下，同样大小的数组，<code>Integer[]</code> 比 <code>int[]</code> 多占用 6 倍内存；</li>
<li>装箱、拆箱还需要额外的计算开销；</li>
</ul>
<p>对于需要 <strong>大量数值计算</strong> 的算法，内存占用 + 装箱、拆箱将明显减缓程序的运行速度，为减缓这些性能开销，<code>Stream</code> 对原始类型和装箱类型做了显式区分，目前仅对：</p>
<ul>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>double</code></li>
</ul>
<p>做了特殊处理，因为它们在数值计算中使用最为广泛。</p>
<p>针对原始类型做特殊处理的方法在命名上有 <strong>明确规范</strong>：</p>
<ul>
<li>若 <strong>返回类型</strong> 为原始类型，则加 <code>to</code>，如 <code>ToLongFunction</code>；</li>
<li>若 <strong>参数</strong> 为原始类型，则不加前缀，如 <code>LongFunction</code>；</li>
<li>若高阶函数使用原始类型，则加 <code>to</code> 加原始类型名，如 <code>mapToLong</code>。</li>
</ul>
<p>Java 8 为原始类型准备了与之对应的 stream，如 <code>IntStream</code>、<code>LongStream</code> 等，而 <code>mapToLong</code> 返回的结果是 <code>LongStream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongStream a = Stream.of(<span class="string">"Hello"</span>, <span class="string">"world!"</span>).mapToLong(String::length);</span><br></pre></td></tr></table></figure>
<p><code>LongStream</code> 中的很多高阶函数实现与普通 <code>Stream</code> 不同，例如 <code>map</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongStream b = a.map(l -&gt; l + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>推荐尽量使用 <code>IntStream</code>、<code>DoubleStream</code> 等特殊处理的 stream，除更好的性能外，<code>IntStream</code> 等还有一些额外的用于数值计算的方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LongStream a = Stream.of(<span class="string">"Hello"</span>, <span class="string">"world!"</span>).mapToLong(String::length);</span><br><span class="line"><span class="comment">// LongSummaryStatistics&#123;count=2, sum=11, min=5, average=5.500000, max=6&#125;</span></span><br><span class="line">LongSummaryStatistics statistics = a.summaryStatistics();</span><br></pre></td></tr></table></figure>
<p><code>summaryStatistics</code> 方法可计算多种统计值，若不需要全部统计值，也可分别获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OptionalLong max = a.max();</span><br><span class="line">OptionalLong min = a.min();</span><br><span class="line"><span class="keyword">long</span> count = a.count();</span><br><span class="line"><span class="keyword">long</span> sum = a.sum();</span><br><span class="line">OptionalDouble average = a.average();</span><br></pre></td></tr></table></figure>
<h3 id="重载解析"><a href="#重载解析" class="headerlink" title="重载解析"></a>重载解析</h3><p>Java 允许方法重载，即方法名字相同，但签名不同，方法重载将影响类型推断，一般而言，Java 编译器将选择 <strong>最具体</strong> 的类型。</p>
<p>现有两个 <code>overloadedMethod</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">overloadedMethod</span><span class="params">(Object o)</span> </span>&#123; System.out.print(<span class="string">"Object"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">overloadedMethod</span><span class="params">(String s)</span> </span>&#123; System.out.print(<span class="string">"String"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法调用 <code>overloadedMethod(&quot;abc&quot;)</code> 将选择第二个，因为参数 <code>String</code> 更加具体，且满足推断条件。</p>
<p>对于 lambda 表达式也是一样，lambda 表达式的类型为对应的 <strong>接口类型</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntegerBiFunction</span> <span class="keyword">extends</span> <span class="title">BinaryOperator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">overloadedMethod</span><span class="params">(BinaryOperator&lt;Integer&gt; Lambda)</span> </span>&#123; System.out.print(<span class="string">"BinaryOperator"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">overloadedMethod</span><span class="params">(IntegerBiFunction Lambda)</span> </span>&#123;</span><br><span class="line">         System.out.print(<span class="string">"IntegerBinaryOperator"</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>方法调用 <code>overloadedMethod((x, y) -&gt; x + y)</code> 将选择 <strong>更具体</strong> 的 <code>IntegerBiFunction</code>。</p>
<p>但有时编译器无法推断出最具体的类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">overloadedMethod</span><span class="params">(Predicate&lt;Integer&gt; predicate)</span> </span>&#123; System.out.print(<span class="string">"Predicate"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">overloadedMethod</span><span class="params">(IntPredicate predicate)</span> </span>&#123; System.out.print(<span class="string">"IntPredicate"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法调用 <code>overloadedMethod((x) -&gt; true)</code> 无法找到 <code>IntPredicate</code> 和 <code>Predicate</code> 之间更具体的那个类型，因为这两者对于该调用”同样具体“，此时编译器将报错，解决方法是把 lambda 表达式强制转换为 <code>IntPredicate</code> 或 <code>Predicate</code>。</p>
<blockquote>
<p>实际上，该现象属于”代码异味“，此时不应该重载 <code>overloadedMethod</code>，应该重新命名。</p>
</blockquote>
<h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a><code>@FunctionalInterface</code></h3><p>前面说过函数接口是只有一个抽象方法的接口，但抽象方法仅仅是函数接口的必要不充分条件。</p>
<p>有的接口恰好只有一个抽象方法，但这并不意味它是为 lambda 表达式设计的，例如 <code>Comparable</code> 和 <code>Closeable</code>，用 lambda 表达式实现两者几乎总是无意义的，因为：</p>
<ul>
<li>一般不认为函数之间存在顺序（<code>Comparable</code>）；</li>
<li>一个操作外部资源，且可能抛出异常的方法（<code>public void close() throws IOException</code>）也不适合实现为 lambda 表达式；</li>
</ul>
<p>作为对比，为提升 <code>Stream</code> 可操作性引入的各种新接口（<code>Predicate</code> 等）都需要用 lambda 表达式实现，因此用 <code>@FunctionalInterface</code> 修饰，防止无意破坏函数接口的条件。</p>
<h3 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h3><p>Java 一直保持向后兼容，即 Java 1-7 编译的类，可以直接运行在 Java 8 上。</p>
<p>Java 8 对集合框架进行了大量修改，例如为 <code>Collection</code> 接口添加了 <code>stream()</code> 方法，为实现向后兼容，所有实现 <code>Collection</code> 接口的类都必须新增 <code>stream</code> 方法，作为 JDK 来讲这问题不大，重新实现这些方法即可；但对于第三方的集合库，比如 <code>MyList</code>，无法强制它新增 <code>stream</code> 方法，因此它们在 Java 8 上无法运行，从而打破向后兼容。</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>为解决向后兼容，Java 8 新增 <strong>默认方法</strong> 特性，如果子类没有重新实现默认方法，则直接使用父类的默认方法。</p>
<p>例如 <code>Collection.stream</code> 被实现为默认方法，若 <code>MyList</code> 没有实现 <code>stream</code>，则可以使用 <code>Collection</code> 的默认实现即可，所以 <code>MyList</code> 也可以运行在 Java 8 上了。</p>
<p><code>Iterable</code> 也新增了一个默认方法 <code>foreach</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认方法和子类"><a href="#默认方法和子类" class="headerlink" title="默认方法和子类"></a>默认方法和子类</h4><p>// TODO</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>接口允许多重继承，因此可能遇到两个父接口包含签名相同的默认方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Jukebox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> String <span class="title">rock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"... all over the world!"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Carriage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> String <span class="title">rock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"... from side to side"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicalCarriage</span> <span class="keyword">implements</span> <span class="title">Carriage</span>, <span class="title">Jukebox</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器无法明确应该继承哪个 <code>rock</code>，因此会报错。在子类中实现 <code>rock</code> 即可解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicalCarriage</span> <span class="keyword">implements</span> <span class="title">Carriage</span>, <span class="title">Jukebox</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Carriage.<span class="keyword">super</span>.rock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>Carriage.super.rock()</code> 用法，Java 8 增强了 <code>super</code> 语法，可以指定调用哪个父接口中的方法。</p>
<h4 id="三定律"><a href="#三定律" class="headerlink" title="三定律"></a>三定律</h4><p>// TODO</p>
<h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h3><p>Java 不支持类的多重继承，但支持接口的多重继承，现在接口支持 <strong>方法实现</strong>，实际上接口已经支持类多重继承的部分功能。Java 原本特意避免类的多重继承，因为多重继承会导致很多问题，其中更根本的原因是 <strong>状态</strong> 的多重继承。</p>
<p>因为接口没有状态（字段），只有行为（方法），因此接口多重继承避免了臭名昭著的 <strong>状态</strong> 继承，也就避免了多重继承的最大问题。</p>
<p>既然接口可以定义方法实现，那它与抽象类还有什么区别吗？</p>
<p>主要区别：</p>
<ul>
<li>接口允许多重继承，但没有成员变量；</li>
<li>抽象类不支持多重继承，但有成员变量；</li>
</ul>
<h3 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h3><p>以前经常把静态方法放到工具类中，但若某静态方法与某个概念强相关，那把该方法与相关类、接口放到一起更加合理。</p>
<p>类自然可以有 <code>static</code> 方法，而 Java 8 开始，接口也可以有 <code>static</code> 方法了，例如 <code>Stream.of</code> 就是静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a><code>Optional</code></h3><p><code>Stream.reduce</code> 既可以提供初始值，也可以不提供，不提供初始值时，将直接从 <code>Stream</code> 的前两个原始开始计算，此时结果类型为 <code>Optional</code>，表示可能不存在有意义的结果。</p>
<p><code>orElse</code> 和 <code>orElseGet</code> 用于当 <code>empty</code> 时提供默认值，若默认值计算量很大，则使用 <code>orElseGet</code>，此时只有是 <code>empty</code> 时才会真正开始计算默认值。</p>
<h2 id="高级集合类和收集器"><a href="#高级集合类和收集器" class="headerlink" title="高级集合类和收集器"></a>高级集合类和收集器</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>lambda 表达式经常调用参数上的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">artist -&gt; artist.getName()</span><br></pre></td></tr></table></figure>
<p>这种做法非常常见，Java 8 为其提供了简写形式，即方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Artist::getName</span><br></pre></td></tr></table></figure>
<p>构造函数也可用方法引用简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(name, nationality) -&gt; <span class="keyword">new</span> Artist(name, nationality)</span><br><span class="line"><span class="comment">// 简化为</span></span><br><span class="line">Artist::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法引用 <strong>自动支持多个参数</strong>，只要顺序正确；</li>
</ul>
<p>可以用方法引用创建数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[]::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>
<h3 id="元素顺序"><a href="#元素顺序" class="headerlink" title="元素顺序"></a>元素顺序</h3><p>在 Java 中有的集合是有序的，例如 <code>List</code>，有的集合是无序的，例如 <code>HashSet</code>。</p>
<p><code>Stream</code> 按照 <strong>出现顺序</strong> 依次处理流中的元素，出现顺序与 <strong>数据源</strong> 有关，从有序集合创建流，则流是有序的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; sameOrder = numbers.stream()</span><br><span class="line">                                 .collect(toList());</span><br><span class="line">assertEquals(numbers, sameOrder);</span><br></pre></td></tr></table></figure>
<p>若数据源是 <strong>无序</strong> 的，则生成的流也是无序的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; numbers = <span class="keyword">new</span> HashSet&lt;&gt;(asList(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">List&lt;Integer&gt; sameOrder = numbers.stream()</span><br><span class="line">                                 .collect(toList());</span><br><span class="line"><span class="comment">// 该断言有时会失败</span></span><br><span class="line">assertEquals(asList(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>), sameOrder);</span><br></pre></td></tr></table></figure>
<p>流顺序除与数据源有关外，还与流的 <strong>操作</strong> 有关，即使数据源是无序的，但流操作可能产生顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; numbers = <span class="keyword">new</span> HashSet&lt;&gt;(asList(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">List&lt;Integer&gt; sameOrder = numbers.stream()</span><br><span class="line">                                 .sorted()</span><br><span class="line">                                 .collect(toList());</span><br><span class="line">assertEquals(asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), sameOrder);</span><br></pre></td></tr></table></figure>
<p>例如 <code>map</code> 这种中间操作将保持流的顺序：</p>
<ul>
<li>处理的流有序，则 <code>map</code> 后的流也有序</li>
<li>处理的流无序，则 <code>map</code> 后的流也无序</li>
</ul>
<blockquote>
<p>部分操作在有序流上 <strong>开销更大</strong>，此时可用 <code>unordered</code> 取消顺序，但大部分操作在有序流上效率更高，如 <code>map</code>、<code>filter</code> 和 <code>reduce</code> 等。</p>
</blockquote>
<p>在并行流上，<code>forEach</code> 无法保证按顺序处理，若要保证顺序，需要用 <code>forEachOrdered</code>。</p>
<h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><p><code>Collector</code> 是通用的、从流生成复杂值的结构。</p>
<p>JDK 提供的收集器定义在 <code>java.util.stream.Collectors</code> 中。</p>
<h4 id="生成其他集合"><a href="#生成其他集合" class="headerlink" title="生成其他集合"></a>生成其他集合</h4><p>常见的有 <code>toList</code>、<code>toSet</code> 和 <code>toCollection</code>。</p>
<p>其中 <code>toList</code> 和 <code>toSet</code> 不需要指定特定的 <code>List</code> 或 <code>Set</code> 类型，<code>Stream</code> 自动挑选合适的具体类型。</p>
<p>若不想底层框架自动挑选，则可用 <code>toCollection</code> 来指定具体集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.collect(toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>toCollection(f)</code> 将使用函数 <code>f</code> 创建用户想要的集合；</li>
</ul>
<h4 id="生成值"><a href="#生成值" class="headerlink" title="生成值"></a>生成值</h4><p><code>maxBy</code> 和 <code>minBy</code> 可按指定顺序生成最大值和最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optional[abc]</span></span><br><span class="line">Optional&lt;String&gt; m = Stream.of(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>).collect(Collectors.maxBy(Comparator.comparingInt(String::length)));</span><br></pre></td></tr></table></figure>
<ul>
<li>注意找到的是长度最长的字符串，而不是最长的长度；</li>
</ul>
<p>计算平均值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.0</span></span><br><span class="line"><span class="keyword">double</span> m = Stream.of(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>).collect(Collectors.averagingInt(String::length));</span><br></pre></td></tr></table></figure>
<h4 id="数据分块"><a href="#数据分块" class="headerlink" title="数据分块"></a>数据分块</h4><p><code>partitioningBy</code> 根据 <code>Predicate</code> 的结果将流分成两个集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;false=[1, 3], true=[2, 4]&#125;</span></span><br><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; partitioned = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(Collectors.partitioningBy(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<h4 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h4><p><code>partitioningBy</code> 只能分成两个集合，<code>groupingBy</code> 可将流分成 <strong>任意数量</strong> 的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;0=[3, 6], 1=[1, 4], 2=[2, 5]&#125;</span></span><br><span class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; grouped = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).collect(Collectors.groupingBy(n -&gt; n % <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>根据与 3 取模的结果对流分组；</li>
<li>类似 SQL 的 group by；</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>默认：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abc</span></span><br><span class="line">String result = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).collect(Collectors.joining());</span><br></pre></td></tr></table></figure>
<p>指定分隔符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b, c</span></span><br><span class="line">String result = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).collect(Collectors.joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>
<p>指定分隔符、前缀、后缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// | a, b, c |</span></span><br><span class="line">String result = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).collect(Collectors.joining(<span class="string">", "</span>, <span class="string">"| "</span>, <span class="string">" |"</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前两者可用 <code>String.join</code> 方法替代，但该方法无法指定前缀和后缀。</p>
</blockquote>
<h4 id="组合收集器"><a href="#组合收集器" class="headerlink" title="组合收集器"></a>组合收集器</h4><p>计算每个艺术家的专辑数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist = albums.collect(groupingBy(album -&gt; album.getMainMusician()));</span><br><span class="line"></span><br><span class="line">Map&lt;Artist, Integer&gt; numberOfAlbums = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Artist, List&lt;Album&gt;&gt; entry : albumsByArtist.entrySet()) &#123;</span><br><span class="line">    numberOfAlbums.put(entry.getKey(), entry.getValue().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是命令式风格，难以并行化，改写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Artist, Long&gt; <span class="title">numberOfAlbums</span><span class="params">(Stream&lt;Album&gt; albums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> albums.collect(groupingBy(album -&gt; album.getMainMusician(), counting()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>groupingBy</code> 对流分组，对于每个分组，使用 <code>counting</code> 进一步处理，结果依然是个 <code>Map</code>，不过 value 是 <code>counting</code> 处理后的结果；</li>
</ul>
<p>若要计算每个艺术家的专辑列表，可用 <code>groupingBy</code> + <code>mapping</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Artist, List&lt;String&gt;&gt; nameOfAlbums(Stream&lt;Album&gt; albums) &#123;</span><br><span class="line">    <span class="keyword">return</span> albums.collect(groupingBy(Album::getMainMusician, mapping(Album::getName, toList())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mapping</code> 需要指定结果的集合类型；</li>
</ul>
<h4 id="自定义收集器"><a href="#自定义收集器" class="headerlink" title="自定义收集器"></a>自定义收集器</h4><p>// TODO</p>
<h4 id="通用的-reduce"><a href="#通用的-reduce" class="headerlink" title="通用的 reduce"></a>通用的 <code>reduce</code></h4><p>// TODO</p>
<p>收集器模仿了 <code>reduce</code> 方法，所有收集器都可以用 <code>reduce</code> 实现。</p>
<h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p>lambda 表达式推动一些新方法加入集合库，例如 <code>Map.computeIfAbsent</code> 等。</p>
<p>之前用 <code>Map</code> 实现缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Artist <span class="title">getArtist</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Artist artist = artistCache.get(name);</span><br><span class="line">    <span class="keyword">if</span> (artist == <span class="keyword">null</span>) &#123;</span><br><span class="line">        artist = readArtistFromDB(name);</span><br><span class="line">        artistCache.put(name, artist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先尝试从缓存读取值，若结果为 <code>null</code>，则从数据库读取，并更新缓存；</li>
</ul>
<p>可用 <code>computeIfAbsent</code> 完美替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Artist <span class="title">getArtist</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> artistCache.computeIfAbsent(name, <span class="keyword">this</span>::readArtistFromDB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真是太方便了！</p>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><h4 id="1-找出名字最长的艺术家"><a href="#1-找出名字最长的艺术家" class="headerlink" title="1. 找出名字最长的艺术家"></a>1. 找出名字最长的艺术家</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; names = Stream.of(<span class="string">"John Lennon"</span>, <span class="string">"Paul McCartney"</span>, <span class="string">"George Harrison"</span>, <span class="string">"Ringo Starr"</span>, <span class="string">"Pete Best"</span>, <span class="string">"Stuart Sutcliffe"</span>);</span><br></pre></td></tr></table></figure>
<p>收集器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; result = names.collect(Collectors.maxBy(Comparator.comparingInt(String::length)));</span><br></pre></td></tr></table></figure>
<p><code>Stream.max</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; result = names.max(Comparator.comparingInt(String::length));</span><br></pre></td></tr></table></figure>
<p><code>Stream.reduce</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; result = names.reduce((l, r) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (l.length() &gt; r.length()) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="2-每个名字的出现次数"><a href="#2-每个名字的出现次数" class="headerlink" title="2. 每个名字的出现次数"></a>2. 每个名字的出现次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; names = Stream.of(<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"John"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;George=1, John=3, Paul=2&#125;</span></span><br><span class="line">Map&lt;String, Long&gt; result = names.collect(Collectors.groupingBy(name -&gt; name, Collectors.counting()));</span><br></pre></td></tr></table></figure>
<h4 id="3-使用-computeIfAbsent-高效的计算斐波那契数列"><a href="#3-使用-computeIfAbsent-高效的计算斐波那契数列" class="headerlink" title="3. 使用 computeIfAbsent 高效的计算斐波那契数列"></a>3. 使用 <code>computeIfAbsent</code> 高效的计算斐波那契数列</h4><p>// TODO</p>
<h2 id="数据并行化"><a href="#数据并行化" class="headerlink" title="数据并行化"></a>数据并行化</h2><p>从外部迭代到内部迭代，不仅带来更好用的接口，也让并行化变得轻而易举。</p>
<h3 id="并行化流操作"><a href="#并行化流操作" class="headerlink" title="并行化流操作"></a>并行化流操作</h3><ul>
<li>若已经有一个流，则调用 <code>parallel</code>；</li>
<li>若要从集合类创建流，则调用 <code>parallelStream</code>；</li>
</ul>
<p>调用 <code>sequential</code> 将转换为串行操作，如果同时调用 <code>sequential</code> 和 <code>parallel</code>，则最后那个生效。</p>
<p>并行流中的 lambda 表达式中不要自行加锁，因为框架会自己处理同步。</p>
<blockquote>
<p>并行流并非速度一定更快，要参考任务规模（太小的话肯定串行更快）、计算资源等。</p>
</blockquote>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>影响并行流速度的主要有 5 个元素：</p>
<ul>
<li>数据大小：只有数据足够大时，并行才有意义；</li>
<li>源数据结构</li>
<li>装箱：<code>IntStream</code> 比 <code>Stream&lt;Integer&gt;</code> 快；</li>
<li>核的数量</li>
<li>元素处理开销：每个元素的处理时间越长，并行带来的好处越大；</li>
</ul>
<p>并行流基于 fork/join 框架，递归分解问题，并行处理，最后归约合并，因此数据源的数据结构是否容易分治处理，将极大影响并行流的性能：</p>
<ul>
<li>性能好<ul>
<li><code>ArrayList</code>、<code>IntStream.range</code> 和数组，支持随机访问，可轻易分治</li>
</ul>
</li>
<li>一般<ul>
<li><code>HashSet</code> 和 <code>TreeSet</code>，可以分治，但不太容易</li>
</ul>
</li>
<li>性能差<ul>
<li><code>LinkedList</code> 难以对半分解</li>
<li><code>Streams.iterate</code>、<code>BufferedReader.lines</code>，长度未知，难以对半</li>
</ul>
</li>
</ul>
<p>数据结构对并行流性能影响很大，例如计算 10 000 个数字的和，<code>ArrayList</code> 比 <code>LinkedList</code> 快 10 倍。</p>
<p>流操作分为有状态和无状态两种：</p>
<ul>
<li>无状态：<code>map</code>、<code>filter</code>、<code>flatMap</code></li>
<li>有状态：<code>sorted</code>、<code>limit</code>、<code>distinct</code></li>
</ul>
<p>无状态操作有利于提升性能！</p>
<h3 id="并行化数组操作"><a href="#并行化数组操作" class="headerlink" title="并行化数组操作"></a>并行化数组操作</h3><p>Java 8 新增了一些数组并行操作函数，都在 <code>Arrays</code> 中：</p>
<ul>
<li><code>parallelPrefix</code></li>
<li><code>parallelSetAll</code></li>
<li><code>parallelSort</code></li>
</ul>
<h4 id="parallelSetAll"><a href="#parallelSetAll" class="headerlink" title="parallelSetAll"></a><code>parallelSetAll</code></h4><p><code>parallelSetAll</code> 并行设置初始值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] xs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line">Arrays.parallelSetAll(xs, i -&gt; i);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>i</code> 为数组索引，以上将数组各元素的值初始化为对应索引值；</li>
<li>原地修改数组，并未创建新数组！</li>
</ul>
<h4 id="parallelPrefix"><a href="#parallelPrefix" class="headerlink" title="parallelPrefix"></a><code>parallelPrefix</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelPrefix</span><span class="params">(<span class="keyword">int</span>[] array, IntBinaryOperator op)</span></span></span><br></pre></td></tr></table></figure>
<p>更新数组，将每个元素替换为新值，新值由 <code>IntBinaryOperator</code> 函数计算而得，以 <strong>当前元素</strong> 以及 <strong>前驱元素</strong> 为参数。</p>
<p>求滑动平均值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] simpleMovingAverage(<span class="keyword">double</span>[] values, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">double</span>[] sums = Arrays.copyOf(values, values.length);</span><br><span class="line">    􏰐Arrays.parallelPrefix(sums, Double::sum);</span><br><span class="line">    <span class="keyword">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(start, sums.length)</span><br><span class="line">                    .mapToDouble(i -&gt; &#123;</span><br><span class="line">                        <span class="keyword">double</span> prefix = i == start ? <span class="number">0</span> : sums[i - n];</span><br><span class="line">                        <span class="keyword">return</span> (sums[i] - prefix) / n;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .toArray();􏰔</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试、调试与重构"><a href="#测试、调试与重构" class="headerlink" title="测试、调试与重构"></a>测试、调试与重构</h2><p><code>peek</code>：</p>
<ul>
<li>强行打印日志，而不结束流（<code>map</code> 之类的方法是 lazy 求值，无法在其中打印日志，<code>forEach</code> 可以打印日志，但它是终止方法，导致流无法继续使用，因此使用 <code>peek</code>）；</li>
<li><code>peek</code> 中可以添加断点，此时 <code>peek</code> 参数方法可以为空，或是简单的 <code>i -&gt; i</code>；</li>
</ul>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/fp/" rel="tag"># fp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/14/2018-08-14-source-code-reading-executor/" rel="next" title="源码分析 | Executor">
                <i class="fa fa-chevron-left"></i> 源码分析 | Executor
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/20/2018-08-20-reading-java-8-lambdas/" rel="prev" title="读书 |《Java 8函数式编程》">
                读书 |《Java 8函数式编程》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Song Kun</p>
              <p class="site-description motion-element" itemprop="description">Java for living, Scala for fun!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">122</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">127</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/satansk" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:songkun.fp@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda-表达式"><span class="nav-number">1.</span> <span class="nav-text">lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final-变量"><span class="nav-number">1.1.</span> <span class="nav-text">final 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数接口"><span class="nav-number">1.2.</span> <span class="nav-text">函数接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">1.3.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流"><span class="nav-number">2.</span> <span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#外部迭代-vs-内部迭代"><span class="nav-number">2.1.</span> <span class="nav-text">外部迭代 vs 内部迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现机制"><span class="nav-number">2.2.</span> <span class="nav-text">实现机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用函数"><span class="nav-number">2.3.</span> <span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#collect-toList"><span class="nav-number">2.3.1.</span> <span class="nav-text">collect(toList())</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">2.3.2.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter"><span class="nav-number">2.3.3.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flatMap"><span class="nav-number">2.3.4.</span> <span class="nav-text">flatMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#max-和-min"><span class="nav-number">2.3.5.</span> <span class="nav-text">max 和 min</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-number">2.3.6.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回-Stream-的方法"><span class="nav-number">2.3.7.</span> <span class="nav-text">返回 Stream 的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多次调用-Stream-操作"><span class="nav-number">2.3.8.</span> <span class="nav-text">多次调用 Stream 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#练习"><span class="nav-number">2.3.9.</span> <span class="nav-text">练习</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类库"><span class="nav-number">3.</span> <span class="nav-text">类库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原始类型"><span class="nav-number">3.1.</span> <span class="nav-text">原始类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载解析"><span class="nav-number">3.2.</span> <span class="nav-text">重载解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FunctionalInterface"><span class="nav-number">3.3.</span> <span class="nav-text">@FunctionalInterface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向后兼容"><span class="nav-number">3.4.</span> <span class="nav-text">向后兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认方法"><span class="nav-number">3.5.</span> <span class="nav-text">默认方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#默认方法和子类"><span class="nav-number">3.5.1.</span> <span class="nav-text">默认方法和子类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-number">3.6.</span> <span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三定律"><span class="nav-number">3.6.1.</span> <span class="nav-text">三定律</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权衡"><span class="nav-number">3.7.</span> <span class="nav-text">权衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口的静态方法"><span class="nav-number">3.8.</span> <span class="nav-text">接口的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional"><span class="nav-number">3.9.</span> <span class="nav-text">Optional</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级集合类和收集器"><span class="nav-number">4.</span> <span class="nav-text">高级集合类和收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法引用"><span class="nav-number">4.1.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素顺序"><span class="nav-number">4.2.</span> <span class="nav-text">元素顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收集器"><span class="nav-number">4.3.</span> <span class="nav-text">收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成其他集合"><span class="nav-number">4.3.1.</span> <span class="nav-text">生成其他集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成值"><span class="nav-number">4.3.2.</span> <span class="nav-text">生成值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据分块"><span class="nav-number">4.3.3.</span> <span class="nav-text">数据分块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据分组"><span class="nav-number">4.3.4.</span> <span class="nav-text">数据分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">4.3.5.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合收集器"><span class="nav-number">4.3.6.</span> <span class="nav-text">组合收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义收集器"><span class="nav-number">4.3.7.</span> <span class="nav-text">自定义收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用的-reduce"><span class="nav-number">4.3.8.</span> <span class="nav-text">通用的 reduce</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些细节"><span class="nav-number">4.4.</span> <span class="nav-text">一些细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习-1"><span class="nav-number">4.5.</span> <span class="nav-text">练习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-找出名字最长的艺术家"><span class="nav-number">4.5.1.</span> <span class="nav-text">1. 找出名字最长的艺术家</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-每个名字的出现次数"><span class="nav-number">4.5.2.</span> <span class="nav-text">2. 每个名字的出现次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-使用-computeIfAbsent-高效的计算斐波那契数列"><span class="nav-number">4.5.3.</span> <span class="nav-text">3. 使用 computeIfAbsent 高效的计算斐波那契数列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据并行化"><span class="nav-number">5.</span> <span class="nav-text">数据并行化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并行化流操作"><span class="nav-number">5.1.</span> <span class="nav-text">并行化流操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能"><span class="nav-number">5.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行化数组操作"><span class="nav-number">5.3.</span> <span class="nav-text">并行化数组操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#parallelSetAll"><span class="nav-number">5.3.1.</span> <span class="nav-text">parallelSetAll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parallelPrefix"><span class="nav-number">5.3.2.</span> <span class="nav-text">parallelPrefix</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试、调试与重构"><span class="nav-number">6.</span> <span class="nav-text">测试、调试与重构</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Song Kun</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.2.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

</body>
</html>
